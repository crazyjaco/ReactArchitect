// ReactArchitectPlugin.js

function ReactArchitectPlugin(options) {
  // Configure your plugin with options...
}

ReactArchitectPlugin.prototype.apply = function(compiler) {
  compiler.plugin("compile", function(params) {
    console.log("The compiler is starting to compile...");
  });

  compiler.plugin("compilation", function(compilation) {
    console.log("The compiler is starting a new compilation...");
    // console.log('compilation', compilation);
    console.log('entry', compilation.compiler.options.entry);
    console.log('entry length: ', compilation.compiler.options.entry.length);
    console.log('exported entry', compilation.compiler.options.entry[(compilation.compiler.options.entry.length - 1)]);

    compilation.plugin("optimize", function() {
      console.log("The compilation is starting to optimize files...");
    });
  });

  compiler.plugin("emit", function(compilation, callback) {
    var deps;
    var objResult = {};
    var outputData = {};
    var chunkArchitecture;

    console.log("The compilation is going to emit files...");
    console.log('\n\n\n');
    //console.log(compilation);
    //console.log('Compilation Props: ', Object.getOwnPropertyNames(compilation));

    //console.log('\n\n\nCompilation Chunks[0].modules[0]: ', compilation.chunks[0].modules[0])
    // 1 chunk per entry point

    // Explore each chunk (build output):
    compilation.chunks.forEach(function(chunk) {
      // Explore each module within the chunk (built inputs):
      chunk.modules.forEach(function(module) {
        // console.log( 'module: ' +  module.id + '  ' + module.request);

      });

      // We start with chunk.modules[0], our entry point
      /*
      chunk.modules[0].dependencies.forEach(function(dep){
        isReactComponent( dep.id, dep._source )
      })
      */

      // Each entry point might emit static assets (optimized images, etc)
      console.log('**** FILES ****');
      if( chunk.files ){
        // Explore each asset filename generated by the chunk:
        chunk.files.forEach(function(filename) {
          // Get the asset source for each file generated by the chunk:
          var source = compilation.assets[filename].source();
        });
      }

      var isReactComponent = function( dep ) {
        // console.log( 'ISREACTCOMPONENT: \n', dep['module']._source );
        // dep._source._value
        // Babel will transpile down to ES5.
        // A component SHOULD include this after transpilation:
        // _react = require("react")
        // function render()
        
        // Check for react import.
        if ( -1 === dep['module']._source._value.indexOf("_react = require(\"react\")") ) {
          return false;
        }

        // Check for render function.
        if ( -1 === dep['module']._source._value.indexOf("function render(") ) {
          return false;
        }

        // Check if render method exists.
        // Check if class extends React.Component 
        return true;
      }

      /**
       * Check if dependecy of a node_module.
       * @param  {string}  depRequest Path of dependency.
       * @return {Boolean}            True = dependency of node_module; False = dep of node_module.
       */
      var isDepOfDep = function( depRequest ) {
        var nodeDepth = 0;
        var isBabelLoader = false;
        if( !depRequest ){ 
          //console.log('depOfDep skipped :', depRequest);
          return;
        }
        // Determine what layer of dependency this is based on path.
        nodeDepth = ( depRequest.split('node_modules').length - 1 );
        // Check if this might be a reference to babel loader
        //   which would be used on the first module.
        isBabelLoader = ( depRequest.split('babel-loader').length - 1 );
        // Let's only grab one layer of node_module dependencies.
        // A dependency of dependency would have a nodeDepth > 1.
        // Also make sure this isn't babel-loader.
        return ( ( 0 < nodeDepth ) ) && ( ! isBabelLoader );
        //return false;
      }

      var extractDepData = function( depEntry, currDepth ){
        var output = {};
        // Verify that depEntry.module exists and that its not a dependency too deep down.
        if( depEntry && depEntry.module && null !== depEntry.module && ! isDepOfDep(depEntry.module.context) ) {
          // RequireHeaderDependency module property is defined but set to null.
          // RequireHeaderDependency does not have a request property/method; ergo undefined.
          // CommonJsRequireDependency is where our desired data lives.      
          output = {
            id: depEntry.module.id,
            request: depEntry.request,
            userRequest: depEntry.userRequest,
            modRequest: depEntry.module.request,
            modUserRequest: depEntry.module.userRequest,
            modRawRequest: depEntry.module.rawRequest,
            component: isReactComponent( depEntry ),
            context: depEntry.module.context,
            depth: currDepth,
            deps: ( depEntry.module.dependencies ) ? getDependencyData( depEntry.module.dependencies, currDepth + 1 ) : []
          };
    //      console.log('extracted.', output);
          return output;
        }
      }

      /**
       * Fire extractDepData on mapped Array entries.
       * @param  {object}  entry    Dependency
       * @param  {integer} index    Position of entry in srcArray.
       * @param  {array}   srcArray Array of depedencies being extracted.
       * @return {array}            Custom extracted data for each depependency.
       */
      var extractDepDataFromArray = function( entry, index, srcArray ) {
        return extractDepData( entry, this.currDepth );
      }

      /**
       * Filter to remove undefined depedency entries.
       * @param  {object}  entry    dependency
       * @param  {integer} index    index of srcArray for entry's position.
       * @param  {array}   srcArray Array being filtered.
       * @return {boolean}           
       */
      var removeUndefinedDepResults = function( entry, index, srcArray ) {
        return undefined !== entry;
      }
      /**
       * Take in the dependency and route it to appropriate function
       * based on it being an an object (single dependency) or array of
       * objects (many dependencies).
       * 
       * @param  {object/array} deps  Passed in depedenc(ies).
       * @param  {integer} currDepth  Current depth of dependency tree.
       * @return {object/array}       Extracted dependencies
       */
      var maybeExtractFromManyDeps = function( deps, currDepth ){
        var output;
        var context = {
          currDepth: currDepth
        }

        if( Array.isArray( deps ) ){
          return deps.map( extractDepDataFromArray, context ).filter( removeUndefinedDepResults );  
        } else {
          return extractDepData( deps, currDepth );
        }
      }

      /**
       * Check if dependency object is empty.
       * This will be called anytime we hit a new set of dependencies.
       * 
       * @param  {object/array} deps  dependenc(ies)
       * @param  {number} currDepth   depth of current spot in dep tree.
       * @return {array}              current set of returned dependencies.
       */
      var getDependencyData = function( deps, currDepth ) {
        // If no dependencies were passed in or its empty, escape early.
        if ( ! deps || 0 === deps.length ) {
          return;
        }
        // If there is only one dependency in deps, it will not be an array.
        return maybeExtractFromManyDeps( deps, currDepth );
      }

      /**
       * Kick off the depedency tree scanning.
       *
       * @param  {object} entryModule Entry point for our chunk.
       * @return {object}             Assembled dependency tree.
       */
      var initTreeParse = function( entryModule ) {
        var depth = 0;
        var result;
        console.log('\n\ninit parse tree called.');
        // We start in the entry point.
        if( ! entryModule.dependencies || 0 === entryModule.dependencies.length ) {
          console.log('init returning');
          return;
        }
        // The last item in the entry array is the actual entry point for each chunk.
        entryPoint = entryModule.dependencies[ entryModule.dependencies.length - 1 ]
        // Dive into the dependencies. Pass the dependencies of the entry point in.
        // Entry point depth is Zero.
        result = getDependencyData( entryPoint.module.dependencies, depth );

        return result;
      }

      // Pass in the entry point and return giant array containing all dependencies.
      chunkArchitecture = initTreeParse( chunk.modules[0] );

      // Transform the array into a valid json file that exports our data.
      file = 'export default ' + JSON.stringify(chunkArchitecture, null, 2);

      // Add our data to the emitted set of assets.
      compilation.assets[ chunk.name + 'Architecture.js'] = {
        source: function() {
          // Designate the contents of our new emitted output data file.
          return file;
        },
        size: function() {
          // Designate the size of our new emitted output data file.
          return file.length;
        }
      }
      console.log('file size:', file.length);
      //console.log('assets: ', compilation.assets);

    });

    // console.log('compilation before emit:', compilation);
    
    // console.log( '\n\n\ncompilation.modules index.js', compilation.modules[0] );

    // console.log( '\n\n\ncompilation.modules react.js', compilation.modules[3] );

    // console.log( '\n\n\ncompilation.modules BGArticleBody', compilation.modules[579] );

    // console.log( '\n\n\ncompilation.modules BGArticleBody _sources', compilation.modules[579]._source );

    // console.log( '\n\n\ncompilation.modules BGArticleBody dependencies', compilation.modules[579].dependencies[0] );



    // deps = compilation.modules[579].dependencies.map(
    //   function(obj){ 
    //     return {
    //       id: obj.id,
    //       rawRequest: obj.rawRequest,
    //       issuer: obj.issuer
    //     };
    //   }
    //   );
    // console.dir('\n\n\ndependencies', deps);
    // console.log('\n\n\nType of compilation.modules:', Array.isArray( compilation.modules ));
    // objResult = compilation.modules.map(
    //   function(obj){
    //     //console.log(obj.id + ' : ' + obj.rawRequest);
    //     return {
    //       id: obj.id,
    //       issuer: obj.issuer,
    //       rawRequest: obj.rawRequest,
    //       context: obj.context,
    //       request: obj.request,
    //       dependencies: obj.dependencies.map(
    //         function(depObj){
    //           if( undefined === depObj.module || null === depObj.module ) {
    //             return;
    //           }
    //           return {
    //             id: depObj.module.id,
    //             context: depObj.context,
    //             request: depObj.request,
    //             module: depObj.module,
    //             dependencies: depObj.dependencies
    //           };
    //         }
    //       ),
    //       depRaw: obj.dependencies
    //     }
    //   }
    // );
    // //console.log('\n\n\nResult object: ', objResult);

    //354 BGArticleInlineImage
    //    console.log('\n\n\nBGArticleInlineImage:\n', objResult[354]);

    //    console.log('\n\n\nBGARticleInlineImage deps: ', objResult[354].dependencies);
    //    console.log('\n\n\nBGARticleInlineImage react dep module: ', objResult[354].dependencies[0].module);

    //    console.log('\n\n\n\n');
    // compilation.modules = [ DependenciesBlock[], DependenciesBlock[] ]
    // id :: dependency id used in sourceMap 1367 maxid; react = 3; 579 = BGArticleBody;
    // rawRequest ::  'react'
    // OriginalSource {
    //   _value: '\'use strict\';\n\nmodule.exports = require(\'./lib/React\');\n',
    //   _name: '/Users/jacobs/Documents/repos/sports2/node_modules/react/react.js' },
    // dependencies: []  array of dependency objects
  


    // compilation.compiler.Compiler._lastCompilationFileDependencies
    // compilation.moduleTemplate
    // issuer
    // compilation.modules.DependenciesBlock{ dependencies:[], context:''}
    // compilation.fileDependencies // array of dependencies; absolute path with file name.
    callback();
  });
};

module.exports = ReactArchitectPlugin;